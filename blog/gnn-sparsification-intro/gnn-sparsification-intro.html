<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Ilias Laoukili">
<meta name="dcterms.date" content="2025-10-19">
<meta name="keywords" content="GNN, sparsification, spectral graph theory, efficiency, robustness, generalization">
<meta name="description" content="A hybrid perspective on spectral, topological, and learning-based sparsification strategies for deploying efficient and reliable graph neural networks.">
<link rel="canonical" href="https://laoukili.com/blog/gnn-sparsification-intro/">
<meta property="og:type" content="article">
<meta property="og:title" content="Understanding Sparsification in Graph Neural Networks">
<meta property="og:description" content="A hybrid perspective on spectral, topological, and learning-based sparsification strategies for efficient and trustworthy GNNs.">
<meta property="og:url" content="https://laoukili.com/blog/gnn-sparsification-intro/">
<meta property="og:image" content="https://laoukili.com/assets/profile-pic.png">
<meta property="og:site_name" content="Ilias Laoukili">
<meta property="article:published_time" content="2025-10-19">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Understanding Sparsification in Graph Neural Networks">
<meta name="twitter:description" content="A hybrid perspective on spectral, topological, and learning-based sparsification strategies for efficient and trustworthy GNNs.">
<meta name="twitter:image" content="https://laoukili.com/assets/profile-pic.png">

<title>Understanding Sparsification in Graph Neural Networks</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="gnn-sparsification-intro_files/libs/clipboard/clipboard.min.js"></script>
<script src="gnn-sparsification-intro_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="gnn-sparsification-intro_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="gnn-sparsification-intro_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="gnn-sparsification-intro_files/libs/quarto-html/popper.min.js"></script>
<script src="gnn-sparsification-intro_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="gnn-sparsification-intro_files/libs/quarto-html/anchor.min.js"></script>
<link href="gnn-sparsification-intro_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="gnn-sparsification-intro_files/libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="gnn-sparsification-intro_files/libs/quarto-html/quarto-syntax-highlighting-dark-707d8167ce6003fca903bfe2be84ab7f.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="gnn-sparsification-intro_files/libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="gnn-sparsification-intro_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="gnn-sparsification-intro_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="gnn-sparsification-intro_files/libs/bootstrap/bootstrap-a74871fe4945b66d259aafc266475145.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="gnn-sparsification-intro_files/libs/bootstrap/bootstrap-dark-534f9e6eb4fde8fa3495dc6c45b1673d.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="gnn-sparsification-intro_files/libs/bootstrap/bootstrap-a74871fe4945b66d259aafc266475145.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<script>
  (function () {
    const storageKey = 'darkMode';
    const classList = document.documentElement.classList;
    const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
    let shouldUseDark = prefersDark;
    try {
      const stored = window.localStorage.getItem(storageKey);
      if (stored !== null) {
        shouldUseDark = stored === 'true';
      }
    } catch (error) {
      shouldUseDark = prefersDark;
    }
    classList.toggle('dark', shouldUseDark);
    document.documentElement.style.colorScheme = shouldUseDark ? 'dark' : 'light';
  })();
</script>
<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "headline": "Understanding Sparsification in Graph Neural Networks",
    "description": "A hybrid perspective on spectral, topological, and learning-based sparsification strategies for efficient and trustworthy GNNs.",
    "datePublished": "2025-10-19",
    "author": {
      "@type": "Person",
      "name": "Ilias Laoukili",
      "url": "https://laoukili.com/"
    },
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "https://laoukili.com/blog/gnn-sparsification-intro/"
    },
    "image": "https://laoukili.com/assets/profile-pic.png",
    "publisher": {
      "@type": "Person",
      "name": "Ilias Laoukili",
      "url": "https://laoukili.com/"
    }
  }
</script>
<link rel="stylesheet" href="../../assets/tailwind.css">
<link rel="stylesheet" href="../../style.css">
</head>

<body class="bg-slate-50 text-slate-800 dark:bg-slate-950 dark:text-slate-200 quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
  toggleColorMode(false);
}
</script>

<a class="skip-link" href="#main-content">Skip to content</a>
<header class="max-w-5xl mx-auto px-6 pt-12 pb-6">
  <a href="../blog.html" class="inline-flex items-center gap-2 text-sm text-slate-600 dark:text-slate-400 hover:text-teal-400">
    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
      <path d="M9.707 15.707a1 1 0 01-1.414 0l-5-5a1 1 0 010-1.414l5-5a1 1 0 111.414 1.414L6.414 9H16a1 1 0 110 2H6.414l3.293 3.293a1 1 0 010 1.414z" />
    </svg>
    Back to blog
  </a>
</header>
<div id="main-content" class="pt-6 pb-16">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="../../../../gnn-sparsification-intro.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li></ul></div></div>
<main class="content" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Understanding Sparsification in Graph Neural Networks</h1>
</div>


<div class="quarto-title-meta-author">
  <div class="quarto-title-meta-heading">Author</div>
  <div class="quarto-title-meta-heading">Affiliation</div>
  
    <div class="quarto-title-meta-contents">
    <p class="author">Ilias Laoukili </p>
  </div>
  <div class="quarto-title-meta-contents">
        <p class="affiliation">
            Tremplin Recherche Project
          </p>
      </div>
  </div>

<div class="quarto-title-meta">

      
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">October 19, 2025</p>
    </div>
  </div>
  
    
  </div>
  
<div>
  <div class="abstract">
    <div class="block-title">Abstract</div>
    <p>We study sparsification for Graph Neural Networks (GNNs) from three complementary viewpoints: (i) <strong>spectral</strong> sparsification that preserves Laplacian quadratic forms; (ii) <strong>topological</strong> sparsification that preserves structural invariants such as connectivity, local neighborhoods, and motif counts; and (iii) <strong>learning-based</strong> sparsification that selects edges (or nodes) with task-aware scores derived from attention or bilevel optimization. Our hybrid perspective clarifies when and how these families align or conflict, and it motivates evaluation beyond accuracy—considering latency, memory, and stability. We outline the research directions of the <em>Tremplin Recherche</em> project on GNN sparsification, including experimental protocols and metrics for efficient and reliable deployment.</p>
  </div>
</div>

<div>
  <div class="keywords">
    <div class="block-title">Keywords</div>
    <p>GNN, sparsification, spectral graph theory, efficiency, robustness, generalization</p>
  </div>
</div>

</header>


<div class="callout callout-style-default callout-note callout-titled" title="Note">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>This article is written in an arXiv-style format for clarity and archival value. It accompanies my <em>Tremplin Recherche</em> work on GNN sparsification. All claims are scoped to commonly accepted definitions; proofs are omitted.</p>
</div>
</div>
<div class="download-links">
<p><a href="gnn-sparsification-intro.pdf" target="_blank" rel="noopener noreferrer">⬇️ Download PDF</a></p>
</div>
<section id="sec-intro" class="level1">
<h1>Introduction</h1>
<p>Modern Graph Neural Networks (GNNs) operate on graphs <span class="math inline">\(G=(V,E,w)\)</span> with <span class="math inline">\(|V|=n\)</span> nodes and <span class="math inline">\(|E|=m\)</span> weighted edges. Despite their expressive power, the computational and memory costs of message passing typically scale with <span class="math inline">\(m\)</span>, creating bottlenecks for large graphs and dense neighborhoods. <strong>Sparsification</strong> seeks to reduce this cost by removing (or reweighting) edges and/or nodes while maintaining task-relevant properties. Beyond efficiency, sparsification can also improve <strong>robustness</strong> (by attenuating noisy edges) and <strong>generalization</strong> (by acting as a structural regularizer).</p>
<p>This note proposes a <strong>hybrid perspective</strong> spanning three families: - <strong>Spectral</strong>: preserve quadratic forms of the graph Laplacian <span class="math inline">\(L\)</span>, i.e., <span class="math inline">\(\forall x,\ (1-\varepsilon)\, x^\top L x \le x^\top \tilde L x \le (1+\varepsilon)\, x^\top L x\)</span>. - <strong>Topological</strong>: preserve qualitative structure (e.g., connectivity, degree profile, ego-nets, motif counts). - <strong>Learning-based</strong>: learn a sparsity pattern from data (e.g., via attention, gates, or bilevel selection) targeting end-task performance.</p>
<p>We articulate how each family connects to GNN message passing and propose a principled <strong>evaluation protocol</strong> covering <em>latency, memory, accuracy,</em> and <em>stability</em>. This provides a unified basis for experimental study in the <strong>Tremplin Recherche</strong> project.</p>
</section>
<section id="sec-background" class="level1">
<h1>Background on Graph Neural Networks</h1>
<section id="graph-representation-and-laplacian" class="level2">
<h2 class="anchored" data-anchor-id="graph-representation-and-laplacian">Graph representation and Laplacian</h2>
<p>Let <span class="math inline">\(A\)</span> be the weighted adjacency, <span class="math inline">\(D\)</span> the degree matrix, and <span class="math inline">\(L=D-A\)</span> the (combinatorial) Laplacian. For normalized propagation one also uses <span class="math inline">\(\mathcal{L}=I-D^{-1/2} A D^{-1/2}\)</span>. The <strong>Rayleigh quotient</strong> <span class="math inline">\(\mathcal{R}_L(x) = \frac{x^\top L x}{x^\top x}\)</span> governs many spectral properties (e.g., cuts, diffusion).</p>
<p>In standard message passing, a GNN layer aggregates neighbor features: <span class="math display">\[
H^{(\ell+1)} = \sigma\!\big(\underbrace{\mathrm{AGG}(A, H^{(\ell)})}_{\text{propagation}} W^{(\ell)}\big),
\]</span> where <span class="math inline">\(\mathrm{AGG}\)</span> encodes a linear diffusion (GCN), an attention-weighted combination (GAT), or other kernels.</p>
</section>
<section id="message-passing-as-approximate-diffusion" class="level2">
<h2 class="anchored" data-anchor-id="message-passing-as-approximate-diffusion">Message passing as (approximate) diffusion</h2>
<p>For GCN-like layers, propagation corresponds to multiplying by a normalized operator <span class="math inline">\(S\)</span> (e.g., <span class="math inline">\(\hat{A}\)</span> or <span class="math inline">\(I-\mathcal{L}\)</span>). Multi-layer stacks approximate polynomials <span class="math inline">\(p(S)\)</span>, linking representation power to the spectrum of <span class="math inline">\(S\)</span>. <strong>Sparsification</strong> affects both the spectrum and the local neighborhoods over which messages are exchanged.</p>
</section>
</section>
<section id="sec-theory" class="level1">
<h1>Sparsification: Definitions and Theoretical Motivation</h1>
<p>We consider three families and their formal desiderata.</p>
<section id="spectral-sparsification" class="level2">
<h2 class="anchored" data-anchor-id="spectral-sparsification">Spectral sparsification</h2>
<p>A graph <span class="math inline">\(\tilde G\)</span> with Laplacian <span class="math inline">\(\tilde L\)</span> is an <span class="math inline">\(\varepsilon\)</span>-<strong>spectral sparsifier</strong> of <span class="math inline">\(G\)</span> if <span class="math display">\[
(1-\varepsilon)\, x^\top L x \ \le\ x^\top \tilde L x \ \le\ (1+\varepsilon)\, x^\top L x,\quad \forall x\in\mathbb{R}^n.
\]</span> This implies preservation of effective resistances and many cut/flow quantities up to <span class="math inline">\(1\pm\varepsilon\)</span>. For propagation operators <span class="math inline">\(S\)</span> derived from <span class="math inline">\(L\)</span>, near-isospectrality yields controlled distortion of diffusion and thus controlled bias in message passing responses.</p>
<p><strong>Implication for GNNs.</strong> When layers implement <span class="math inline">\(S\)</span>-based smoothing, maintaining spectral bounds helps preserve frequency responses, attenuating oversmoothing or instabilities caused by large spectral perturbations.</p>
</section>
<section id="topological-sparsification" class="level2">
<h2 class="anchored" data-anchor-id="topological-sparsification">Topological sparsification</h2>
<p>Topological criteria ensure that <span class="math inline">\(\tilde G\)</span> preserves structure such as connectivity, local degrees, hop neighborhoods, and selected subgraph counts (triangles, motifs). Typical constraints include <span class="math display">\[
\delta_{\text{deg}} = \max_{v\in V} \frac{|d_G(v) - d_{\tilde G}(v)|}{\max(1,d_G(v))} \le \tau,
\qquad
\text{and}\quad \mathrm{Conn}(\tilde G)=\mathrm{Conn}(G).
\]</span> <strong>Implication for GNNs.</strong> Message quality depends on neighborhood integrity. Preserving ego-nets and motif frequencies stabilizes attention weights and local mixing patterns used by expressive GNN variants.</p>
</section>
<section id="learning-based-sparsification" class="level2">
<h2 class="anchored" data-anchor-id="learning-based-sparsification">Learning-based sparsification</h2>
<p>Given labeled data <span class="math inline">\((G, X, Y)\)</span>, define a sparsity mask <span class="math inline">\(M\in\{0,1\}^{n\times n}\)</span> (or relaxed <span class="math inline">\(M\in[0,1]\)</span>) applied to edges, with learnable parameters <span class="math inline">\(\theta\)</span>. Optimize <span class="math display">\[
\min_{\theta}\ \mathcal{L}_{\text{task}}\!\big(f_\theta(G\odot M, X), Y\big) + \lambda \|M\|_0 \quad
\text{s.t. (optionally) } M\in\mathcal{C},
\]</span> where <span class="math inline">\(\mathcal{C}\)</span> encodes constraints (budget, connectivity, degree caps, etc.). This yields task-aware sparsity patterns, often via attention scores, Gumbel-Softmax, or bilevel schemes.</p>
<p><strong>Implication for GNNs.</strong> End-to-end selection can outperform purely structural criteria when labels are informative, but risks overfitting and distribution shift; constraints and validation protocols become crucial.</p>
</section>
</section>
<section id="sec-hybrid" class="level1">
<h1>A Hybrid Perspective and Its Tensions</h1>
<p>While spectral, topological, and learning-based approaches overlap, they are <strong>not equivalent</strong>:</p>
<ul>
<li>Spectral guarantees control <em>global</em> diffusion error but may alter local motifs;</li>
<li>Topological preservation maintains neighborhoods yet can drift spectrally;</li>
<li>Learning-based selection optimizes task metrics but may violate either spectral or topological constraints, hurting robustness.</li>
</ul>
<p>We therefore propose <strong>hybrid sparsification</strong> combining: 1. <strong>Spectral guardrails</strong>: enforce bounds on <span class="math inline">\(\|L-\tilde L\|\)</span> or on effective resistances; 2. <strong>Topological fidelity</strong>: constrain degree deviation, connectivity, or motif counts within tolerances; 3. <strong>Task-aware refinement</strong>: learn residual scores subject to (1)–(2).</p>
<p>This induces a constrained optimization view: <span class="math display">\[
\min_{M,\ \tilde w}\ \mathcal{L}_{\text{task}}\big(f(G_M^{\tilde w}, X), Y\big)
\quad\text{s.t.}\quad
\begin{cases}
(1-\varepsilon)\, x^\top L x \le x^\top \tilde L x \le (1+\varepsilon)\, x^\top L x, &amp; \forall x,\\
\mathrm{Conn}(G_M)=\mathrm{Conn}(G),\ \delta_{\text{deg}}\le \tau,\ \text{motif\_err}\le \eta,\\
\|M\|_0 \leq B.
\end{cases}
\]</span> Here <span class="math inline">\(G_M^{\tilde w}\)</span> denotes the masked and reweighted graph, <span class="math inline">\(B\)</span> the edge budget.</p>
</section>
<section id="sec-motivation" class="level1">
<h1>Why Sparsification Matters (Efficiency, Robustness, Generalization)</h1>
<p>We motivate a <strong>balanced</strong> view spanning efficiency, robustness, and generalization.</p>
<section id="efficiency-scalability" class="level2">
<h2 class="anchored" data-anchor-id="efficiency-scalability">Efficiency (scalability)</h2>
<p>Compute and memory scale roughly with the number of edges used per layer. If <span class="math inline">\(\tilde m \ll m\)</span> then forward/backward costs and activation memory drop proportionally, enabling larger batches or deeper models. On-device inference also benefits from reduced latency.</p>
</section>
<section id="robustness-stability-to-noise" class="level2">
<h2 class="anchored" data-anchor-id="robustness-stability-to-noise">Robustness (stability to noise)</h2>
<p>Edge noise (spurious similarities, measurement artifacts) can amplify through message passing. Spectral guardrails bound diffusion error; topological constraints stabilize neighborhood formation; learning-based priors can downweight unreliable edges.</p>
</section>
<section id="generalization-regularization" class="level2">
<h2 class="anchored" data-anchor-id="generalization-regularization">Generalization (regularization)</h2>
<p>Sparsity reduces hypothesis complexity: fewer edge-mediated interactions can act as structural regularization, mitigating oversmoothing and overfitting—provided constraints avoid under-connection.</p>
</section>
</section>
<section id="sec-objective" class="level1">
<h1>Research Objective (Tremplin Recherche)</h1>
<p><strong>Goal.</strong> Develop and evaluate <strong>hybrid sparsification</strong> for GNNs that achieves <strong>(i)</strong> near-spectral fidelity, <strong>(ii)</strong> topology preservation within tolerances, and <strong>(iii)</strong> competitive or improved task performance under a fixed sparsity budget.</p>
<p><strong>Hypothesis.</strong> Constrained, task-aware sparsification outperforms purely spectral or purely learned selection on <em>efficiency–robustness–accuracy</em> trade-offs, particularly under distribution shift and limited labels.</p>
</section>
<section id="sec-experiments" class="level1">
<h1>Planned Experiments and Metrics</h1>
<section id="datasets-and-tasks" class="level2">
<h2 class="anchored" data-anchor-id="datasets-and-tasks">Datasets and tasks</h2>
<ul>
<li>Node/edge classification and graph classification benchmarks (e.g., citation-style graphs, molecules, or social nets) depending on availability and licensing in your environment.</li>
<li>For each dataset: construct baseline dense GNNs (e.g., GCN/GraphSAGE/GAT).</li>
</ul>
</section>
<section id="sparsification-methods" class="level2">
<h2 class="anchored" data-anchor-id="sparsification-methods">Sparsification methods</h2>
<ol type="1">
<li><strong>Spectral</strong> baselines: sampling by effective resistance / leverage-like scores; reweighting via Laplacian scaling.</li>
<li><strong>Topological</strong> baselines: degree-capped pruning; kNN-backbones; motif-preserving heuristics.</li>
<li><strong>Learning-based</strong>: attention-thresholding; differentiable edge gates; bilevel selection with connectivity constraints.</li>
<li><strong>Hybrid (proposed)</strong>: constrained learning with spectral guardrails and topology tolerances.</li>
</ol>
</section>
<section id="metrics" class="level2">
<h2 class="anchored" data-anchor-id="metrics">Metrics</h2>
<ul>
<li><strong>Accuracy/ROC</strong> (primary task metrics).</li>
<li><strong>Latency</strong> (ms) and <strong>throughput</strong> (samples/s) at inference.</li>
<li><strong>Memory</strong> (peak activation + parameters).</li>
<li><strong>Spectral distortion</strong>: max/min ratio of Rayleigh quotients on probe vectors; eigenspectrum shift.</li>
<li><strong>Topological distortion</strong>: degree deviation <span class="math inline">\(\delta_{\text{deg}}\)</span>, connectivity, motif error.</li>
<li><strong>Stability</strong>: variation under stochastic edge noise or feature noise.</li>
</ul>
</section>
<section id="protocol" class="level2">
<h2 class="anchored" data-anchor-id="protocol">Protocol</h2>
<ul>
<li>Fix a <strong>sparsity budget</strong> <span class="math inline">\(B\)</span> (or density <span class="math inline">\(\rho=\tilde m/m\)</span>).</li>
<li>Sweep <span class="math inline">\(\varepsilon,\tau,\eta\)</span> (spectral/topology tolerances) and report Pareto curves (latency vs.&nbsp;accuracy, stability vs.&nbsp;accuracy).</li>
<li>Report ablations: spectral-only, topology-only, learning-only, and <strong>hybrid</strong>.</li>
</ul>
</section>
</section>
<section id="sec-roadmap" class="level1">
<h1>Roadmap</h1>
<ol type="1">
<li><strong>Phase I — Foundations.</strong> Implement spectral and topology baselines; build metric suite (spectral/topological distortion, latency, memory).</li>
<li><strong>Phase II — Learning-based selection.</strong> Train attention/gating with edge budgets and connectivity constraints.</li>
<li><strong>Phase III — Hybrid constraints.</strong> Add spectral guardrails via penalties or projections; tune tolerances.</li>
<li><strong>Phase IV — Robustness.</strong> Evaluate under noise/perturbations; study transfer across datasets.</li>
<li><strong>Phase V — Write-up &amp; release.</strong> Consolidate results, reproducible code, and benchmarks.</li>
</ol>
</section>
<section id="sec-conclusion" class="level1">
<h1>Conclusion</h1>
<p>Sparsification for GNNs is not a single objective but a <strong>triad</strong> of desiderata—efficiency, robustness, and generalization. A <strong>hybrid</strong> approach can reconcile spectral fidelity, topological integrity, and task-aware selection. This note frames the problem, proposes metrics and protocols, and sets the stage for the <em>Tremplin Recherche</em> experimental program.</p>
</section>
<section id="sec-references" class="level1">
<h1>References</h1>
<p><em>(A minimal placeholder. Replace or extend with your <code>.bib</code> entries as you progress. No external sources are asserted here.)</em></p>
<ul>
<li>Standard texts on spectral graph theory and GNN message passing.</li>
<li>Works on spectral sparsification (e.g., near-Laplacian preservation).</li>
<li>Studies on topology-preserving sampling and motif-aware sparsification.</li>
<li>Learning-based sparsification via attention or differentiable gates.</li>
</ul>
</section>

</main>
<!-- /main column -->
<script>
  (function () {
    const storageKey = 'darkMode';
    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
    const htmlEl = document.documentElement;
    const bodyEl = document.body;

    const ensureThemeMeta = () => {
      let meta = document.querySelector('meta[name="theme-color"]');
      if (!meta) {
        meta = document.createElement('meta');
        meta.setAttribute('name', 'theme-color');
        document.head.appendChild(meta);
      }
      return meta;
    };

    const themeMeta = ensureThemeMeta();

    const ensureStyles = () => {
      if (document.querySelector('style[data-theme-toggle-style]')) {
        return;
      }
      const style = document.createElement('style');
      style.setAttribute('data-theme-toggle-style', '');
      style.textContent = `
:root {
  --toggle-bg-light: #f8fafc;
  --toggle-bg-dark: rgba(15, 23, 42, 0.92);
  --toggle-fg-light: #1f2937;
  --toggle-fg-dark: #e2e8f0;
  --toggle-border-light: rgba(148, 163, 184, 0.8);
  --toggle-border-dark: rgba(71, 85, 105, 0.8);
}
[data-theme-toggle] {
  position: fixed;
  bottom: 1.5rem;
  right: 1.5rem;
  width: 3rem;
  height: 3rem;
  border-radius: 9999px;
  display: grid;
  place-items: center;
  cursor: pointer;
  background: var(--toggle-bg-light);
  color: var(--toggle-fg-light);
  border: 1px solid var(--toggle-border-light);
  box-shadow: 0 14px 32px rgba(15, 23, 42, 0.12);
  transition: transform 0.2s ease, background 0.2s ease, color 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
  z-index: 100;
}
[data-theme-toggle]:hover {
  transform: translateY(-2px);
  box-shadow: 0 18px 38px rgba(15, 23, 42, 0.18);
}
[data-theme-toggle]:focus-visible {
  outline: 2px solid rgba(45, 212, 191, 0.9);
  outline-offset: 3px;
}
[data-theme-toggle] svg {
  width: 1.35rem;
  height: 1.35rem;
}
[data-theme-toggle][data-theme="dark"] {
  background: var(--toggle-bg-dark);
  color: var(--toggle-fg-dark);
  border-color: var(--toggle-border-dark);
}
[data-theme-toggle][data-theme="light"] svg[data-icon="moon"],
[data-theme-toggle][data-theme="dark"] svg[data-icon="sun"] {
  display: none;
}
[data-theme-toggle][data-theme="light"] svg[data-icon="sun"],
[data-theme-toggle][data-theme="dark"] svg[data-icon="moon"] {
  display: block;
}
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  border: 0;
}
@media (prefers-reduced-motion: reduce) {
  [data-theme-toggle] {
    transition: none;
  }
  [data-theme-toggle]:hover {
    transform: none;
  }
}
@media print {
  [data-theme-toggle] {
    display: none;
  }
}
      `.trim();
      document.head.appendChild(style);
    };

    ensureStyles();

    const removeAlternateFormats = () => {
      const alt = document.querySelector('.quarto-alternate-formats');
      if (alt && alt.parentElement) {
        alt.parentElement.remove();
      } else if (alt) {
        alt.remove();
      }
    };

    removeAlternateFormats();

    const applyQuartoMode = (isDark) => {
      if (!bodyEl) return;
      bodyEl.classList.toggle('quarto-dark', isDark);
      bodyEl.classList.toggle('quarto-light', !isDark);
      bodyEl.setAttribute('data-bs-theme', isDark ? 'dark' : 'light');

      const bootstrapLink = document.getElementById('quarto-bootstrap');
      if (bootstrapLink) {
        const lightHref = bootstrapLink.getAttribute('data-href-light');
        const darkHref = bootstrapLink.getAttribute('data-href-dark');
        if (lightHref && darkHref) {
          const desiredHref = isDark ? darkHref : lightHref;
          if (desiredHref && bootstrapLink.getAttribute('href') !== desiredHref) {
            bootstrapLink.setAttribute('href', desiredHref);
          }
        }
        bootstrapLink.setAttribute('data-mode', isDark ? 'dark' : 'light');
      }
    };

    const createFloatingToggle = () => {
      const existing = document.querySelector('.quarto-color-scheme-toggle');
      const markup = `
          <span class="sr-only">Toggle color theme</span>
          <svg xmlns="http://www.w3.org/2000/svg" data-icon="sun" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
            <path fill-rule="evenodd" d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z" clip-rule="evenodd" />
          </svg>
          <svg xmlns="http://www.w3.org/2000/svg" data-icon="moon" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
            <path d="M17.293 13.293A8 8 0 016.707 2.707a8 8 0 1010.586 10.586z" />
          </svg>
        `;
      if (existing) {
        existing.setAttribute('data-theme-toggle', '');
        existing.setAttribute('aria-pressed', 'false');
        existing.setAttribute('aria-label', 'Toggle color theme');
        existing.classList.remove('top-right');
        if (existing.tagName.toLowerCase() === 'a') {
          existing.removeAttribute('href');
          existing.removeAttribute('onclick');
          existing.setAttribute('role', 'button');
          existing.setAttribute('tabindex', '0');
        }
        existing.innerHTML = markup;
        return existing;
      }

      const button = document.createElement('button');
      button.type = 'button';
      button.classList.add('quarto-color-scheme-toggle');
      button.setAttribute('data-theme-toggle', '');
      button.setAttribute('aria-pressed', 'false');
      button.setAttribute('aria-label', 'Toggle color theme');
      button.innerHTML = markup;
      document.body.appendChild(button);
      return button;
    };

    createFloatingToggle();

    const toggleButtons = document.querySelectorAll('[data-theme-toggle]');

    const setTheme = (isDark, persist = false) => {
      htmlEl.classList.toggle('dark', isDark);
      applyQuartoMode(isDark);
      if (persist) {
        localStorage.setItem(storageKey, String(isDark));
      }
      if (themeMeta) {
        themeMeta.setAttribute('content', isDark ? '#0f172a' : '#f8fafc');
      }
      toggleButtons.forEach((button) => {
        button.setAttribute('aria-pressed', String(isDark));
        button.setAttribute('data-theme', isDark ? 'dark' : 'light');
      });
    };

    const getStoredPreference = () => localStorage.getItem(storageKey);

    const initializeTheme = () => {
      const stored = getStoredPreference();
      const shouldUseDark = stored === 'true' || (stored === null && mediaQuery.matches);
      setTheme(shouldUseDark);
    };

    initializeTheme();

    toggleButtons.forEach((button) => {
      button.addEventListener('click', () => {
        const isDark = !htmlEl.classList.contains('dark');
        setTheme(isDark, true);
      });
    });

    mediaQuery.addEventListener('change', (event) => {
      if (getStoredPreference() === null) {
        setTheme(event.matches);
      }
    });
  })();
</script>
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->

</div>
<footer class="py-8 text-center text-slate-500 dark:text-slate-400 text-sm border-t border-slate-200 dark:border-slate-800">
      © Ilias Laoukili
</footer>
<script src="../../assets/site.js" defer></script>
</body></html>
